#
# expectations that clean up in case of error. Note that `$test' is
# a purely local variable.
#
# The first of these is used to match any bad responses, and resynchronise
# things by finding a prompt. The second is a timeout error, and shouldn't
# ever be triggered.
#

#______________________________________________________________________________
# A meta-function that causes all the test description data to be loaded into
# memory

proc load_test_data { filePath platform } {
    global testData

    set testData(FILE_PATH) "$filePath"
    loadMetaSeries [ file join "$filePath" [ file join "global" "META_SERIES.csv" ] ]
    loadSeries [ file join "$filePath" [ file join "global" "SERIES.csv" ] ]
    loadTestData "$filePath" "$platform"
    loadInitData "$filePath" "$platform"
    loadBoilerPlates "$filePath" "$platform"
    loadEnvironments "$filePath" "$platform"
}


#______________________________________________________________________________
# A function that loads the series names for the given meta-series

proc loadMetaSeries { fileName } {
    global testData

    set file [open $fileName r]
    if { $file == 0 } {
        send_user "Zero file id\n"
    } else {
        gets $file line
        gets $file line
        if { ! [ eof $file ] } {
            set count 0
            foreach key [ split $line ";" ] {
                set key [ string trim $key ]
                if { ! [ string equal "" $key ] } {
                    set key [ string range "$key" 1 end ]
                    set key [ string range "$key" 0 end-1 ]
                    set fields($key) $count
                }
                set count [ expr $count + 1 ]
            }
        }

        set count 0
        set line ""
        while { $count >= 0 } {
            set count [gets $file line]
            if { $count < 0 } { break }

            set line [ string trim $line ]
            set row [ split $line ";" ]
            set metaName [ string trim [ lindex $row $fields(META_SERIES_NAME) ] ]
            set testName [ string trim [ lindex $row $fields(SERIES_NAME) ] ]
            set seq [ string trim [ lindex $row $fields(SEQUENCE) ] ]
            if { [ string equal "" [ array names result "$metaName" ] ] } {
                set result($metaName) ""
            }
            set result($metaName) [ concat $result($metaName) \
                            [ list [ list "$testName" $seq ] ] ]
        }
        close $file
    }

    foreach key [ array names result ] {
        set testData(META_$key) [ lsort -integer -index 1 $result($key) ]
    }
}

#______________________________________________________________________________
# A function that loads the test names for the different series

proc loadSeries { fileName } {
    global testData

    set file [open $fileName r]
    if { $file == 0 } {
        send_user "Zero file id\n"
    } else {
        gets $file line
        gets $file line
        if { ! [ eof $file ] } {
            set count 0
            foreach key [ split $line ";" ] { 
                set key [ string trim $key ]  
                if { ! [ string equal "" $key ] } { 
                    set key [ string range "$key" 1 end ]
                    set key [ string range "$key" 0 end-1 ]
                    set fields($key) $count 
                } 
                set count [ expr $count + 1 ] 
            }
        }

        set count 0
        set line ""
        while { $count >= 0 } {
            set count [gets $file line]
            if { $count < 0 } { break }

            set line [ string trim $line ]
            set row [ split $line ";" ]
            set seriesName [ string trim [ lindex $row $fields(SERIES_NAME) ] ]
            set testName [ string trim [ lindex $row $fields(TEST_NAME) ] ]
            set seq [ string trim [ lindex $row $fields(SEQUENCE) ] ]
            if { [ string equal "" [ array names result "$seriesName" ] ] } {
                set result($seriesName) ""
            }
            set result($seriesName) [ concat $result($seriesName) \
                    [ list [ list "$testName" $seq ] ] ]
        }
        close $file
    }

    foreach key [ array names result ] {
        set testData(SERIES_$key) [ lsort -integer -index 1 $result($key) ]
    }
}




#______________________________________________________________________________
# A function that loads the TCS init data (ie, expected output) for the
# given test

proc loadInitData { filePath platform } {
    global testData
    set pass 0
 
    while { $pass < 2 } {
        set pass [expr $pass + 1]
        if { $pass == 1 } {
            set subDir "global"
        } else {
            set subDir "$platform"
        }
        set file [open [ file join "$filePath" [ file join "$subDir" "INIT.csv" ] ] r]

        gets $file line
        gets $file line
        if { ! [ eof $file ] } {
            set count 0
            foreach key [ split $line ";" ] {
                set key [ string trim $key ]
                if { ! [ string equal "" $key ] } {
                    set key [ string range "$key" 1 end ]
                    set key [ string range "$key" 0 end-1 ]
                    set fields($key) $count
                }  
                set count [ expr $count + 1 ]
            }
        }

        set count 0
        set line ""
        while { $count >= 0 } {
            set count [gets $file line]
            if { $count < 0 } { break }

            set line [ string trim $line ]
            set row [ split $line ";" ]
            set name [ string trim [ lindex $row $fields(TEST_NAME) ] ]
            set output [ string trim [ lindex $row $fields(OUTPUT) ] ]
            set output [ file join "$subDir" "$output" ]
            set vers [ string trim [ lindex $row $fields(VERSION) ] ]
            if { [ string equal "" [ array names result "$name" ] ] } {
                set result($name) [ list "$output" $vers ]
            } else {
                if { $vers >= [ lindex $result($name) 1 ] } {
                    set result($name) [ list "$output" $vers ]
                }
            }
        }
        close $file
    }
    foreach key [ array names result ] {
        set testData(INIT_$key) $result($key)
    }
}


#______________________________________________________________________________
# A function that loads the test data for a given test.  This data includes
# the input script.

proc loadTestData { filePath platform } {
    global testData
    set pass 0
 
    while { $pass < 2 } {
        set pass [expr $pass + 1]
        if { $pass == 1 } {
            set subDir "global"
        } else {
            set subDir "$platform"
        }
        set file [open [ file join "$filePath" [ file join "$subDir" "TESTS.csv" ] ] r]

        gets $file line
        gets $file line
        if { ! [ eof $file ] } {
            set count 0
            foreach key [ split $line ";" ] {
                set key [ string trim $key ]
                if { ! [ string equal "" $key ] } {
                    set key [ string range "$key" 1 end ]
                    set key [ string range "$key" 0 end-1 ]
                    set fields($key) $count
                }  
                set count [ expr $count + 1 ]
            }
        }

        set count 0
        set line ""
        while { $count >= 0 } {
            set count [gets $file line]
            if { $count < 0 } { break }

            set line [ string trim $line ]
            set row [ split $line ";" ]
            set name [ string trim [ lindex $row $fields(TEST_NAME) ] ]
            set script [ string trim [ lindex $row $fields(SCRIPT) ] ]
            set script [ file join "$subDir" "$script" ]
            set vers [ string trim [ lindex $row $fields(VERSION) ] ]
            set runFlag [ string trim [ lindex $row $fields(NO_RUN_FLAG) ] ]
            set initFlag [ string trim [ lindex $row $fields(NO_INIT_FLAG) ] ]
            if { [ string equal "" [ array names result "$name" ] ] } {
                set result($name) [list "$script" "$runFlag" "$initFlag" $vers ]
            } else {
                if { $vers >= [ lindex $result($name) 3 ] } {
                    set result($name) [list "$script" "$runFlag" "$initFlag" $vers ]
                }
            }
        }
        close $file
    }

    foreach key [ array names result ] {
        set testData(TEST_$key) $result($key)
    }
}


#______________________________________________________________________________
# A function that loads the boiler plate info

proc loadBoilerPlates { filePath platform } {
    global testData
    set pass 0
 
    while { $pass < 2 } {
        set pass [expr $pass + 1]
        if { $pass == 1 } {
            set subDir "global"
        } else {
            set subDir "$platform"
        }
        set file [open [ file join "$filePath" [ file join "$subDir" "BOILER_PLATE.csv" ] ] r]
        gets $file line
        gets $file line
        if { ! [ eof $file ] } {
            set count 0
            foreach key [ split $line ";" ] {
                set key [ string trim $key ]
                if { ! [ string equal "" $key ] } {
                    set key [ string range "$key" 1 end ]
                    set key [ string range "$key" 0 end-1 ]
                    set fields($key) $count
                }  
                set count [ expr $count + 1 ]
            }
        }

        set count 0
        set line ""
        while { ! [eof $file ] } {
            set count [gets $file line]
            if { [ eof $file ] } { continue }

            set line [ string trim $line ]
            set row [ split $line ";" ]
            set bpName [ string trim [ lindex $row $fields(BOILER_PLATE_NAME)] ]
            set result($bpName) [ file join "$subDir" [ string trim [ lindex $row $fields(SCRIPT) ] ] ]

        }
        close $file
    }
    foreach key [ array names result ] {
        set testData(BP_$key) $result($key)
    }
}


#______________________________________________________________________________
# A function that loads the environment info

proc loadEnvironments { filePath platform } {
    global testData
    set pass 0
 
    while { $pass < 2 } {
        set pass [expr $pass + 1]
        if { $pass == 1 } {
            set subDir "global"
        } else {
            set subDir "$platform"
        }
        set file [open [ file join "$filePath" [ file join "$subDir" "ENV.csv" ] ] r]
        gets $file line
        gets $file line
        if { ! [ eof $file ] } {
            set count 0
            foreach key [ split $line ";" ] {
                set key [ string trim $key ]
                if { ! [ string equal "" $key ] } {
                    set key [ string range "$key" 1 end ]
                    set key [ string range "$key" 0 end-1 ]
                    set fields($key) $count
                }  
                set count [ expr $count + 1 ]
            }
        }

        set count 0
        set line ""
        while { ! [eof $file ] } {
            set count [gets $file line]
            if { [ eof $file ] } { continue }

            set line [ string trim $line ]
            set row [ split $line ";" ]
            set envName [ string trim [ lindex $row $fields(ENV_NAME) ] ]
            set result($envName) [ file join "$subDir" [ string trim [ lindex $row $fields(PROLOG) ] ] ]

        }
        close $file
    }
    foreach key [ array names result ] {
        set testData(ENV_$key) $result($key)
    }
}


#______________________________________________________________________________
# The code to handle command substitution in the tcs.script data stream
#
proc parseEnvFile { fileName } {
    global tcsEnv
    global localEnv

    set result ""
    set file [ open $fileName r ]
    while { ! [ eof $file ] } {
        gets $file line
        if { [ eof $file ] } { continue }

        if { [ string first "::" "$line" ] != 0 } { continue }
        set line [ string range "$line" 2 end ]
        set offset [ string first " " "$line" ]
        if { $offset == -1 } {
            set srcStr "$line"
            set rplStr ""
        } else {
            set srcStr [ string range "$line" 0 [ expr $offset - 1 ]]
            set rplStr [ string range "$line" [expr $offset + 1 ] end ]
        }
        set result [ concat $result [ list [ list "$srcStr" "$rplStr" ] ] ]
        set tcsEnv($srcStr) "$rplStr"
        set localEnv($srcStr) "$rplStr"
    }
    close $file
    return $result
}


#______________________________________________________________________________
# The code to handle command substitution in the tcs.script data stream
#

proc setup_tcsenv {} {
    global tcsEnv
    global localEnv
    global firebird
    global firebirdTCS

    set localEnv(PATH_SEP) "/"
    set localEnv(gds_\$print_status) "gds__print_status"
    set localEnv(gds_\$status) "gds__status"
    set localEnv(GDS_\$QUAD) "GDS__QUAD"
    set localEnv(gds_\$quad) "gds__quad"
    set localEnv(GDS_\$DECODE_DATE) "GDS__DECODE_DATE"
    set localEnv(gds_\$decode_date) "gds__decode_date"
    set localEnv(LINE_TERM) "\n"

    set localEnv(WHERE_GDB) ""
    set tcsEnv(WHERE_GDB) ""
    set localEnv(WHERE_FILES) "" 
    set tcsEnv(WHERE_FILES) "" 
        
    set tcsEnv(WHERE_BIN) [ file join "$firebird" "bin" ]
    set tcsEnv(WHERE_GSEC) "$firebird"
    set tcsEnv(WHERE_HELP) [ file join "$firebird" "help" ]
    set tcsEnv(WHERE_INCLUDE3) [ file join "$firebird" "include" ]

    set tcsEnv(ADA_LINK) ""
    set tcsEnv(ADA_MKFAM) ""
    set tcsEnv(ADA_MKLIB) ""
    set tcsEnv(ADA_RMFAM) ""
    set tcsEnv(ADA_RMLIB) ""
    set tcsEnv(ADA_SEARCH) ""
    set tcsEnv(ADA_SETLIB) ""
    set tcsEnv(ADA) ""
    set tcsEnv(API) "api"
    set tcsEnv(CC) "cc"
    set tcsEnv(CXX) "CC"
    set tcsEnv(COBOL) "cob"
    set tcsEnv(COB_LINK) "cob"
    set tcsEnv(COB) "cob"
    set tcsEnv(COPY) "cp "
    set tcsEnv(CREATE) "cat > "
    set tcsEnv(CRE) "cat > "
    set tcsEnv(DELETE) "rm -f "
    set tcsEnv(DEL) "rm -f "
    set tcsEnv(DIRECTORY) "ls "
    set tcsEnv(DIR) "ls "
    set tcsEnv(DROP) [ file join "$firebirdTCS" "drop_gdb" ]
    set tcsEnv(FORTRAN_LINK) "f77"
    set tcsEnv(FORTRAN) "f77"
    set tcsEnv(FOR) "f77"
    set tcsEnv(GBAK) [ file join "$firebird" [ file join "bin" "gbak" ] ]
    set tcsEnv(GCON) [ file join "$firebird" [ file join "bin" "gcon" ] ]
    set tcsEnv(GCSU) [ file join "$firebird" [ file join "bin" "gcsu" ] ]
    set tcsEnv(GDEF) [ file join "$firebird" [ file join "bin" "gdef" ] ]
    set tcsEnv(GDS_CACHE_MANAGER) [ file join "$firebird" [ file join "bin" "gds_cache_manager" ] ]
    set tcsEnv(GFIX) [ file join "$firebird" [ file join "bin" "gfix" ] ]
    set tcsEnv(GJRN) [ file join "$firebird" [ file join "bin" "gjrn" ] ]
    set tcsEnv(GLTJ) [ file join "$firebird" [ file join "bin" "gltj" ] ]
    set tcsEnv(GPRE) [ file join "$firebird" [ file join "bin" "gpre" ] ]
    set tcsEnv(GRST) [ file join "$firebird" [ file join "bin" "grst" ] ]
    set tcsEnv(GSEC) [ file join "$firebird" [ file join "bin" "gsec" ] ]
    set tcsEnv(ISQL) [ file join "$firebird" [ file join "bin" "isql" ] ]
    set tcsEnv(JAVA) "java"
    set tcsEnv(JAVAC) "javac"
    set tcsEnv(MAKE) "make"
    set tcsEnv(PASCAL) "pas"
    set tcsEnv(PAS) "pas"
    set tcsEnv(QLI) [ file join "$firebird" [ file join "bin" "qli" ] ]
    set tcsEnv(RSH) "rsh"
    set tcsEnv(RUN) ""
    set tcsEnv(SH) "sh"
    set tcsEnv(TYPE) "cat < "
    set tcsEnv(LINK) "cc"

    set tcsEnv(HOST_CODE_EXT_C) "c"
    set tcsEnv(HOST_CODE_EXT_CXX) "cpp"
    set tcsEnv(HOST_CODE_EXT_ADA) "a"
    set tcsEnv(HOST_CODE_EXT_FTN) "ftn"
    set tcsEnv(HOST_CODE_EXT_PAS) "p"
    set tcsEnv(HOST_CODE_EXT_COB) "cbl"
}

proc platform_code_ext { fileName } {
    global tcsEnv

    set posOfDot [string last "." $fileName ]
    
    if { $posOfDot == -1 } {
        return "$tcsEnv(HOST_CODE_EXT_C)"
    }
    
    set curExt [ string range $fileName $posOfDot end ]
        
    if { ! [string compare "$curExt" ".c"] } {
        return "$tcsEnv(HOST_CODE_EXT_C)" }
    if { ! [string compare "$curExt" ".C"] } {
        return "$tcsEnv(HOST_CODE_EXT_CXX)" }
    if { ! [string compare "$curExt" ".a"] } {
        return "$tcsEnv(HOST_CODE_EXT_ADA)" }
    if { ! [string compare "$curExt" ".ftn"] } {
        return "$tcsEnv(HOST_CODE_EXT_FTN)" }
    #if { ! [string compare "$curExt" ".??"] } {
    #    return "$tcsEnv(HOST_CODE_EXT_PAS)" }
    if { ! [string compare "$curExt" ".cbl"] } {
        return "$tcsEnv(HOST_CODE_EXT_COB)" }

    # I wonder if we want to do this, or would it be better to return
    # the current extention $curExt even though we don't know it.
    #
    # JMB - or we could just fail the test.
    return ""
}

proc platform_code_root { fileName } {
    set posOfDot [string last "." $fileName ]
    
    if { $posOfDot == -1 } {
        return "$fileName"
    } else {
        return [ string range $fileName 0 [ expr $posOfDot - 1 ] ]
    }
}

proc debugPrint { line } {
#    send_user "$line\n"
}       

proc cmd_sub { line } {
    global tcsEnv

    debugPrint "initial: $line"

    set cmdList [ split "$line" { } ]
    set line ""
    while { [llength "$cmdList"] > 0 } {
        set item [ lindex "$cmdList" 0 ]
        set cmdList [ lrange "$cmdList" 1 end ]

        # handle the compile variable
        if { [ string compare "FLAG_CC" "$item" ] == 0      || \
             [ string compare "FLAG_CXX" "$item" ] == 0     || \
             [ string compare "FLAG_ADA" "$item" ] == 0     || \
             [ string compare "FLAG_FOR" "$item" ] == 0     || \
             [ string compare "FLAG_PAS" "$item" ] == 0     || \
             [ string compare "FLAG_COB" "$item" ] == 0 } {

            set fileName [ lindex "$cmdList" 0 ]
            set cmdList [ lrange "$cmdList" 1 end ]
            set prtPat "$tcsEnv($item)"
            set item [ format "$prtPat" "[platform_code_root $fileName].[platform_code_ext $fileName]" ]
            set line "$line $item"
            continue
        }

        # handle the link variable
        if { [ string compare "FLAG_LINK" "$item" ] == 0      || \
             [ string compare "FLAG_ADA_LINK" "$item" ] == 0     || \
             [ string compare "FLAG_COB_LINK" "$item" ] == 0 } {

            set fileName [ lindex "$cmdList" 0 ]
            set cmdList [ lrange "$cmdList" 1 end ]
            set prtPat "$tcsEnv($item)"
            set item [ format "$prtPat" "[platform_code_root $fileName].o" "$fileName" ]
            set line "$line $item"
            continue
        }

        if { [ string length $item ] != 0 } {
            set findNames [ array names tcsEnv "$item" ]
            debugPrint "map: X${item}X Y${findNames}Y"

            # Check lookup to see if we have found a match (done this way so that
            # wildcards such as 'A*' still work ok.
            if { $findNames != $item  } {
                set line "$line $item"
            } else {
                set line "$line $tcsEnv($item)"
            }
        }
    }
    set line [ string range "$line" 1 end ]
    debugPrint "final: $line"

    return [ data_sub "$line" ]
}

proc data_sub { str } {
    global localEnv
    global tcsEnv

#    send_user "orig : $str\n"

    set newStr ""
    set checkStr ""

    while { [string length "$str"] > 0 } {
        if { [string is wordchar -failindex stopChar "$str"] } {
            set checkStr "$checkStr$str"
            set str ""
        } else {
            if { $stopChar == 0 } {
                # we won't let the rest of the loop complete because it might
                # call 'array names localEnv "*"', which breaks the rest of
                # the code.  Since we only pick up funny characters in this
                # if branch we just update newStr and go to the next iteration
                #
                set tmpStr [ string range "$str" 0 0 ]
                set checkStr ""
                set str [ string range "$str" 1 end ]
                set newStr "$newStr$tmpStr"
                continue

            } else {
                set tmpStr [ string range "$str" 0 [ expr $stopChar - 1 ] ]
                set checkStr "$checkStr$tmpStr"
                set str [ string range "$str" $stopChar end ]

                # check for special characters that are not in the wordchar class
                # but that should not break words.  Most notably the '$' can't
                # break words.
                if { [ string equal {$} [ string range "$str" 0 0 ] ] } {
                    set checkStr "$checkStr\$"
                    set str [ string range "$str" 1 end ]
                    continue
                }
            }
        }

        # check to see if need to do a string replacement

        if { [string equal "" [ array names localEnv "$checkStr" ] ] } {
            # nope
            set newStr "$newStr$checkStr"

        } else {
            # do an extra check to consume a trailing : for empty substitutions
            #  needed to handle WHERE_GDB:xxxx.gdb style substitutions
            set strLen [ string length "$str" ]
            if { [ string equal "" "$localEnv($checkStr)" ] && $strLen > 0 } {
                if { [ string equal ":" [ string range "$str" 0 0 ] ] } {
                    # consume the ":"
                    set str [ string range "$str" 1 end ]
                }
                # no replacement is needed, because the replace pattern is empty
            } else {
                set newStr "$newStr$localEnv($checkStr)"
                # check to see if we need to stick in the path separator
                if { $strLen > 0 } {
                    if { [ string equal ":" [ string range "$str" 0 0 ] ] } {
                        # consume the ":"
                        set str [ string range "$str" 1 end ]
                        set newStr "$newStr$localEnv(PATH_SEP)"
                    }
                }
            }
        }
        set checkStr ""
    }

    # The old, slow, cruddy substitution code
    #
    #foreach key [ array names localEnv "WHERE_*" ] {
    #    if { ! [ string compare "" "$localEnv($key)" ] } {
    #        set rplStr ""
    #    } else {
    #        set rplStr "$localEnv($key)/"
    #    }
    #
    #    regsub -all "$key:" "$str" "$rplStr" str
    #}
    #
    #foreach key [ array names localEnv ] {
    #    regsub -all "$key" "$str" "$localEnv($key)" str
    #}
    #

#    send_user "new  : $str\n"
    return "$newStr"
}

proc linesAreEquiv { source comp } {
    if { [ regexp "((SQL> )|(CON> ))*Database:  " "$source" matchStr ] } {
        if { [ string first "$matchStr" "$comp" ] == 0 } {
            return 1
        }
    }

    set matchPos [ string last "CREATE DATABASE" [ string toupper "$source"] ]
    if { $matchPos != -1 && $matchPos <= 14 } {
        if { [ string length "$comp" ] > 14 } {
            if { [ string compare "CREATE DATABASE" [ string range [ string toupper "$comp" ] 0 14 ] ] == 0 } {
                return 1
            }
        }
    }

    # the default action
    return [ expr [ string compare "$source" "$comp" ] == 0 ]
}

proc start_shell {} {
    global spawn_id
    global shellPrompt
    global localEnv

    spawn "/bin/sh"
    set shellPrompt "shell> "
    send "PS1='$shellPrompt'$localEnv(LINE_TERM)"
    set timeout 10
    expect {
        -re "\[^\]*\[^\'\]$shellPrompt" { return 1 }
        timeout { send_user "TIMEOUT\n" }
        eof { send_user "Premature EOF!!\n" }
    }
    send "exit$localEnv(LINE_TERM)"
    return 0
}

proc stop_shell {} {
    global spawn_id
    global shellPrompt
    global localEnv

    send "exit$localEnv(LINE_TERM)"
    set timeout 10
    expect {
        eof { return 1 }
        timeout { }
    }
    return 0
}



# This is the fun little procedure that correctly handles the stdout/stderr
# streams.

proc doTcsDiff { srcScript outputFile } {
    global testTimeout
    global localEnv
    global spawn_id
    global shellPrompt

    set errLine ""
    set splitFile 0
    set errBuff ""
    set fileOpen 1
    set failMsg ""
    set blankCount 0
    set lastMatch 1

    set stdoutMatch 1
    set stderrMatch 0
    set timeout 5

# Change the shell prompt to something we can recognise, this is mainly
# for windows where a lot of colour escape characters are used in the prompt.
    send "$localEnv(LINE_TERM)"
    expect {
        -re "$shellPrompt" { }
        timeout {
            stop_shell
            if { ! [ start_shell ] } {
                send_user "Unrecoverable error!\n"
            }
            return "TIMEOUT waiting for starting shell prompt"
        }
        eof { set fileOpen 0; fail "Premature EOF!!"; start_shell; return }
    }

    set timeout $testTimeout
    send "source $srcScript$localEnv(LINE_TERM)"

#        -re {^[^\r\n]*$srcScript\r\n} { }
    expect {
        -re "source $srcScript\[\r\n\]+" { }
        timeout {
            stop_shell
            if { ! [ start_shell ] } {
                send_user "Unrecoverable error!\n"
            }
            return "TIMEOUT waiting for script command echo"
        }
        eof { set fileOpen 0; set failMsg "Premature EOF!!" }
    }

    set file [ open "$outputFile" r ]

    while { ! [ eof $file ] } {
        if { $stdoutMatch == 1 } {
            gets $file line
            if { [eof $file] } { continue }
        }
        if { $stderrMatch == 1 } {
            if { [ llength $errBuff ] == 0 } {
                set errLine ""
                set splitFile 2
            } else {
                set errLine [ lindex $errBuff 0 ]
                set errBuff [ lrange $errBuff 1 end ]
                #send_user "errline: $errLineX\n"
                #send_user $errBuff
                #send_user "\n"
            }
        }

        set stdoutMatch 0
        set stderrMatch 0
        set wildcardMatch 0
        set timeout $testTimeout

# On win32 some of the returned lines have \r\r\n as the delimiter
# the [ have to be escaped, and # comments cannot appear in the
# expect statement.
        expect {
            -re "^\[^\r\n\]*\r\r\n" {
                set output [ string range "$expect_out(buffer)" 0 end-3 ] }
            -re "^\[^\r\n\]*\r\n" {
                set output [ string range "$expect_out(buffer)" 0 end-2 ] }

            timeout {
                stop_shell
                if { ! [ start_shell ] } {
                    send_user "Unrecoverable error!\n"
                }
                set fileOpen 0
                set failMsg "TIMEOUT waiting for: $output"
                break
            }
            eof { set fileOpen 0; set failMsg "Premature EOF!!"; break }
        }

#        set output [ string trim "$expect_out(buffer)" ]
#        set line   [ string trim $line ]
#        send_user "$output\n"

        if { [ linesAreEquiv "$line" "$output" ] } {
            # This is a funny case.  It basically says if the last matched line
            # came from stderr, the current line is blank (""), and both
            # of the next expected lines for stdout and stderr are blank, give
            # the blank space to stderr.
            if { [ string compare "" "$line" ] == 0  && \
                 $lastMatch == 2 && $splitFile == 1 && \
                 [ string compare "" "$errLine" ] == 0 } {
                set stderrMatch 1
            } else {
                set stdoutMatch 1
            }
        } else {
            if {$splitFile == 1 && [ linesAreEquiv "$errLine" "$output"] } {
                set stderrMatch 1
            } else {
                set wildcardMatch 1
            }
        }

        # Check to see if the wildcard failed because of a 'special' line
        # if not then we have a test error
        if { $wildcardMatch == 1 } {
            # test error case
            if { $splitFile != 0 } {
                set failMsg "Unexpected output: $output"
                break
            }

            if { $splitFile == 0 } {
                # There is funny problem with the "" string when searching for
                # the start of the stdout stream.  Basically, you match a blank
                # in the stderr stream instead of the stdout stream.  We just
                # ignore blanks for now.  That is safe because the must have
                # come from stdout, or else stderr *would* have matched and we
                # wouldn't be here.  Instead we just count the number of blanks
                # we ignore and insure they are at the beginning of the stdout
                # stream once we find it.
                if { [string compare "" "$output"] == 0 } {
                    set blankCount [ expr $blankCount + 1 ]
                } else {
                    # At this point we assume the output file is split, and
                    # search for the line that matches the current ouput line.
                    # We just assume
                    # that this line is the start of the stdout stream.
                    set splitFile 1
                    set foundMatch 0
                    while { ! [ eof $file ] } {
                        gets $file checkLine
                        if { [eof $file] } { continue }
                        if { [ linesAreEquiv "$checkLine" "$output" ] } {
                            set foundMatch 1
                            break
                        }
                        set errBuff [ concat $errBuff [ list "$checkLine" ] ]
                    }
                    if { $foundMatch == 0 } {
                        set failMsg "Unexpected output: $output"
                        break
                    }
                    set errLine "$line"
                    set stdoutMatch 1
                    set stderrMatch 0
                    while { $blankCount > 0 } {
                        set blankCount [ expr $blankCount - 1 ]
                        set checkItem [ lindex $errBuff end ]
                        set errBuff [ lrange $errBuff 0 end-1 ]
                        if { [ string compare "$checkItem" "" ] != 0 } {
                            set failMsg "Unexpected blank in stream"
                            break
                        }
                    }
                    #send_user $errBuff
                    #send_user "\n"
                }
            }
        }

        if { $stdoutMatch == 1 } {
            #send_user "stdout: $output\n"
            set lastMatch 1
        }
        if { $stderrMatch == 1 } {
            #send_user "stderr: $output\n"
            set lastMatch 2
        }
    }
    if { $fileOpen == 0 } { return $failMsg }

    set timeout $testTimeout
    expect {
        -re "$shellPrompt" { }
        timeout { set failMsg "TIMEOUT waiting for last shell prompt" }
        timeout {
            stop_shell
            if { ! [ start_shell ] } {
                send_user "Unrecoverable error!\n"
            }
            set failMsg "TIMEOUT waiting for last shell prompt"
        }
        eof { set fileOpen 0; set failMsg "Premature EOF!!"; break }
    }

    close $file
    return $failMsg
}

#______________________________________________________________________________
# The code to run a single test
#
# My reading of the input file format is everything before the first $ command
#  is a comment.  All lines of code between two $'s constitute a data file
#   (a tcs.dataX file).

proc runKnownTest { scriptFile dataFiles outputFile bpFile envFile keep_files } {
    global saveSeriesDataRoot
    global saveSeriesResultsRoot
    global testData

    set lastCmd ""

    set dataCnt -1
    set lastWasCmd 0
    set dataFileOpen 0
    set testFiles "tcs.script"

    set file [open "$scriptFile" r]
    set script [open "tcs.script" w]
    set env [ parseEnvFile "$envFile" ]

    # Copy over the boiler plate
    set bp [ open "$bpFile" r ]
    while { ! [ eof $bp ] } {
        set count [ gets $bp line ]
        if { $count < 0 } { continue }
        puts $script "$line"
    }
    close $bp

    # Break the source script into tcs.script and tcs.dataX
    while { ! [ eof $file ] } {
        set count [gets $file line]
        if { $count < 0 } { continue }

        set matchPos [string last {$} "$line" ]
        if { $matchPos != 0 } {
            if { $lastWasCmd == 1 && [ string length "$line" ] > 0 } {
                set lastWasCmd 0
                set dataCnt [ expr $dataCnt + 1 ]
                set dataFile [open "tcs.data$dataCnt" w]
                set dataFileOpen 1
                set testFiles [ concat $testFiles "tcs.data$dataCnt" ]
                puts $script "$lastCmd < tcs.data$dataCnt"
            }
            if { $dataFileOpen == 1 } {
                puts $dataFile [ data_sub "$line" ]
            }
        } else {
            if { $dataFileOpen == 1 } {
                close $dataFile
                set dataFileOpen 0
            }
            if { $lastWasCmd == 1 } { puts $script "$lastCmd" }
            set lastWasCmd 1
            set line [ string trim [ string range "$line" 1 end ] ]
            set lastCmd [ cmd_sub $line ]
        }
    }
    if { $lastWasCmd == 1 } { puts $script "$lastCmd" }

    if { $dataFileOpen == 1 } {
        close $dataFile
        set dataFileOpen 0
    }

    close $script
    close $file

    foreach dataFile "$dataFiles" {
        set in [ open "$dataFile" r ]
        set out [ open [ file tail "$dataFile" ] w ]
        while { ! [ eof $in ] } {
            gets $in line
            if { [ eof $in ] } { break }
            puts $out [ data_sub "$line" ]
        }
        close $in
        close $out
    }

    # Now that all the files have been extracted, lets run the test!!
    set testResult [ doTcsDiff "tcs.script" "$outputFile" ]

    # delete the files we created
    if { ! $keep_files } {
        foreach filename $testFiles { file delete -force $filename }
        foreach filename $dataFiles \
            { file delete -force [ file tail "$filename" ] }
    }

    return $testResult
}


#______________________________________________________________________________
# The code to run a series

proc runKnownSeries { seriesName subSeries platform } {
    global testData
    set seriesName [ string toupper "$seriesName" ]
    set subSeries [ string toupper "$subSeries" ]
    set prefix "testsuite/tcs.test/data/global/$seriesName"
    set oprefix "testsuite/tcs.test/data/output/$seriesName"
    set envprefix "testsuite/tcs.test/data/global/tcs_setup"
    set errMsg ""

    if { [ catch {open [ file join "$prefix" "$subSeries.series" ] r} fid] } {
        fail "Failed to open series TOC for $seriesName: $fid"
        return
    }

    while { ! [eof $fid ] } {
        gets $fid line
        if { [ eof $fid ] } { continue }

	send_user "\t$line..."
        set line [ string trim $line ]
        if { [ catch {runKnownTest [ file join "$prefix" "$line.script" ] "" \
                              [ file join "$oprefix" "$line.output" ] \
                              [ file join "$envprefix" "BP.$platform" ] \
                              [ file join "$envprefix" "ENV.$platform" ] \
          0} errMsg ] } {
            fail "Exception caught: $errMsg"
        }
        if { [ string equal "" "$errMsg" ] } {
            send_user "PASS\n"
            pass "$line"
        } else {
            fail "$line $errMsg"
        }
    }
    close $fid
}

#______________________________________________________________________________
# The code to run a meta-series

proc runMetaSeries { metaSeries platform } {
    global testData
    set metaSeries [ string toupper "$metaSeries" ]

    if { [ catch {open "testsuite/tcs.test/data/global/$metaSeries.meta" r} fid] } {
        fail "Failed to open meta series TOC for $metaSeries: $fid"
        return
    }
    while { ! [eof $fid ] } {
        gets $fid line
        if { [ eof $fid ] } { continue }

        set line [ string trim $line ]
	send_user "$line...\n"
        runKnownSeries "$line" "$line" "$platform"
    }
    close $fid
}



#______________________________________________________________________________
# The code to locate the series a test resides in given the test name

proc runTest { testName platform saveFiles } {
    set testName [ string toupper "$testName" ]

    send_user "$testName..."
    if { [ catch { glob "testsuite/tcs.test/data/global/*/$testName.script" } test_list ] } {
        fail "$testName $test_list"
        return;
    }
    if { [ llength "$test_list" ] != 1 } {
        fail "$testName Ambigous test name"
        return
    }
    set testScript [ lindex "$test_list" 0 ]
    set seriesName [ lindex [ file split "$testScript" ] end-1 ]

    set prefix "testsuite/tcs.test/data/global/$seriesName"
    set oprefix "testsuite/tcs.test/data/output/$seriesName"
    set envprefix "testsuite/tcs.test/data/global/tcs_setup"
    set errMsg ""

    if { [ catch {runKnownTest "$testScript" "" \
                              [ file join "$oprefix" "$testName.output" ] \
                              [ file join "$envprefix" "BP.$platform" ] \
                              [ file join "$envprefix" "ENV.$platform" ] \
      $saveFiles } errMsg ] } {
        fail "Exception caught: $errMsg"
    }
    if { [ string equal "" "$errMsg" ] } {
        send_user "PASS\n"
        pass "$testName"
    } else {
        fail "$testName $errMsg"
    }
}



#______________________________________________________________________________
# The code to locate a sub-series and run it, given a name

proc runSeries { seriesName platform } {
    set seriesName [ string toupper "$seriesName" ]

    send_user "$seriesName...\n"
    if { [ catch { glob "testsuite/tcs.test/data/global/*/$seriesName.series" } test_list ] } {
        fail "$seriesName $test_list"
        return;
    }
    if { [ llength "$test_list" ] != 1 } {
        fail "$seriesName Ambigous series name"
        return
    }

    set masterSeriesName [ lindex [ file split "$test_list" ] end-1 ]
    runKnownSeries "$masterSeriesName" "$seriesName" "$platform"
}


#______________________________________________________________________________
# The code that does the testing

set moduleName TCS
set databaseName "work/limits.gdb"
setup_tcsenv
#load_test_data "testsuite/tcs.test/data" "darwin"

#send_user "$argv0\n"

set platform darwin

#set saveSeriesDir /tmp/fred1
set saveSeriesDataRoot testsuite/tcs.test/data
set saveSeriesResultsRoot testsuite/tcs.test/results

set exportedData ../test-files/export

set testTimeout 180

if { ! [start_shell] } {
    send_user "Failed to start shell!!\n"
}

#runMetaSeries VECTOR_12HOUR    $platform

#runSeries CF_ISQL             $platform

#runSeries C_SQL_PRED          $platform
#runSeries ISC_ARRBLOB_CK      $platform

#runSeries DSQL_DOMAINS        $platform
#runSeries DSQL_EXCEPTIONS     $platform
#runSeries SQL_EVENTS          $platform
#runSeries C_SQL_BLOB          $platform
#runSeries C_SQL_JOIN          $platform
#runSeries V4_AUTO_COMMIT      $platform
#runSeries V4_EXCLUSIVE        $platform
#runSeries IDML_C_CHARSET      $platform
#runSeries IDML_C_SUBQUERYS    $platform

#set testTimeout 60000
#runSeries EVENT_MISC          $platform

#set testTimeout 60

runSeries EXT_LEV_0           $platform
#runSeries GF_SHUTDOWN         $platform
#runSeries QA_PROC_IES_ERR     $platform
#runSeries REF_INT_INDX        $platform
#runSeries RICH_FLD_GEN_V40    $platform
#runSeries RI_TESTS            $platform
#runSeries V4_AUTO_DDL_DSQL    $platform
#runSeries V4_TRANS_BLOB       $platform
#runSeries QA_PROCS_ISQL       $platform
#runSeries FB_SQL              $platform


#runTest ISC_ER36 $platform 1

#runTest C_SQL_JOIN_0  $platform 1
#runTest CF_ISQL_01  $platform 1
#runTest CF_ISQL_11  $platform 1
#runTest CF_ISQL_16  $platform 1

#runTest DSQL_DOMAIN_08  $platform 1
#runTest DSQL_EXCEPT_01  $platform 1

#set timeout 20000
#runTest SQL_EVENT_12  $platform 1
#runTest GF_SHUT_2  $platform 1


# The following has a problem with LD -> ld in the input file.
#runTest CF_ISQL_17  $platform 1


# just testing
#runTest C_SQL_PRED_0  $platform 1
#runTest AUTO_COMMIT.1.ESQL $platform 1
#runTest IDML_C_SUBQ_10 $platform 1

stop_shell
