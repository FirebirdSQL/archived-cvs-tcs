#
# expectations that clean up in case of error. Note that `$test' is
# a purely local variable.
#
# The first of these is used to match any bad responses, and resynchronise
# things by finding a prompt. The second is a timeout error, and shouldn't
# ever be triggered.
#

#______________________________________________________________________________
# A meta-function that causes all the test description data to be loaded into
# memory

proc load_test_data { filePath platform } {
    global testData

    set testData(FILE_PATH) "$filePath"
    loadMetaSeries [ file join "$filePath" [ file join "global" "META_SERIES.csv" ] ]
    loadSeries [ file join "$filePath" [ file join "global" "SERIES.csv" ] ]
    loadTestData "$filePath" "$platform"
    loadInitData "$filePath" "$platform"
    loadBoilerPlates "$filePath" "$platform"
    loadEnvironments "$filePath" "$platform"
}


#______________________________________________________________________________
# A function that loads the series names for the given meta-series

proc loadMetaSeries { fileName } {
    global testData

    set file [open $fileName r]
    if { $file == 0 } {
        send_user "Zero file id\n"
    } else {
        gets $file line
        gets $file line
        if { ! [ eof $file ] } {
            set count 0
            foreach key [ split $line ";" ] {
                set key [ string trim $key ]
                if { ! [ string equal "" $key ] } {
                    set key [ string range "$key" 1 end ]
                    set key [ string range "$key" 0 end-1 ]
                    set fields($key) $count
                }
                set count [ expr $count + 1 ]
            }
        }

        set count 0
        set line ""
        while { $count >= 0 } {
            set count [gets $file line]
            if { $count < 0 } { break }

            set line [ string trim $line ]
            set row [ split $line ";" ]
            set metaName [ string trim [ lindex $row $fields(META_SERIES_NAME) ] ]
            set testName [ string trim [ lindex $row $fields(SERIES_NAME) ] ]
            set seq [ string trim [ lindex $row $fields(SEQUENCE) ] ]
            if { [ string equal "" [ array names result "$metaName" ] ] } {
                set result($metaName) ""
            }
            set result($metaName) [ concat $result($metaName) \
                            [ list [ list "$testName" $seq ] ] ]
        }
        close $file
    }

    foreach key [ array names result ] {
        set testData(META_$key) [ lsort -integer -index 1 $result($key) ]
    }
}

#______________________________________________________________________________
# A function that loads the test names for the different series

proc loadSeries { fileName } {
    global testData

    set file [open $fileName r]
    if { $file == 0 } {
        send_user "Zero file id\n"
    } else {
        gets $file line
        gets $file line
        if { ! [ eof $file ] } {
            set count 0
            foreach key [ split $line ";" ] { 
                set key [ string trim $key ]  
                if { ! [ string equal "" $key ] } { 
                    set key [ string range "$key" 1 end ]
                    set key [ string range "$key" 0 end-1 ]
                    set fields($key) $count 
                } 
                set count [ expr $count + 1 ] 
            }
        }

        set count 0
        set line ""
        while { $count >= 0 } {
            set count [gets $file line]
            if { $count < 0 } { break }

            set line [ string trim $line ]
            set row [ split $line ";" ]
            set seriesName [ string trim [ lindex $row $fields(SERIES_NAME) ] ]
            set testName [ string trim [ lindex $row $fields(TEST_NAME) ] ]
            set seq [ string trim [ lindex $row $fields(SEQUENCE) ] ]
            if { [ string equal "" [ array names result "$seriesName" ] ] } {
                set result($seriesName) ""
            }
            set result($seriesName) [ concat $result($seriesName) \
                    [ list [ list "$testName" $seq ] ] ]
        }
        close $file
    }

    foreach key [ array names result ] {
        set testData(SERIES_$key) [ lsort -integer -index 1 $result($key) ]
    }
}




#______________________________________________________________________________
# A function that loads the TCS init data (ie, expected output) for the
# given test

proc loadInitData { filePath platform } {
    global testData
    set pass 0
 
    while { $pass < 2 } {
        set pass [expr $pass + 1]
        if { $pass == 1 } {
            set subDir "global"
        } else {
            set subDir "$platform"
        }
        set file [open [ file join "$filePath" [ file join "$subDir" "INIT.csv" ] ] r]

        gets $file line
        gets $file line
        if { ! [ eof $file ] } {
            set count 0
            foreach key [ split $line ";" ] {
                set key [ string trim $key ]
                if { ! [ string equal "" $key ] } {
                    set key [ string range "$key" 1 end ]
                    set key [ string range "$key" 0 end-1 ]
                    set fields($key) $count
                }  
                set count [ expr $count + 1 ]
            }
        }

        set count 0
        set line ""
        while { $count >= 0 } {
            set count [gets $file line]
            if { $count < 0 } { break }

            set line [ string trim $line ]
            set row [ split $line ";" ]
            set name [ string trim [ lindex $row $fields(TEST_NAME) ] ]
            set output [ string trim [ lindex $row $fields(OUTPUT) ] ]
            set output [ file join "$subDir" "$output" ]
            set vers [ string trim [ lindex $row $fields(VERSION) ] ]
            if { [ string equal "" [ array names result "$name" ] ] } {
                set result($name) [ list "$output" $vers ]
            } else {
                if { $vers >= [ lindex $result($name) 1 ] } {
                    set result($name) [ list "$output" $vers ]
                }
            }
        }
        close $file
    }
    foreach key [ array names result ] {
        set testData(INIT_$key) $result($key)
    }
}


#______________________________________________________________________________
# A function that loads the test data for a given test.  This data includes
# the input script.

proc loadTestData { filePath platform } {
    global testData
    set pass 0
 
    while { $pass < 2 } {
        set pass [expr $pass + 1]
        if { $pass == 1 } {
            set subDir "global"
        } else {
            set subDir "$platform"
        }
        set file [open [ file join "$filePath" [ file join "$subDir" "TESTS.csv" ] ] r]

        gets $file line
        gets $file line
        if { ! [ eof $file ] } {
            set count 0
            foreach key [ split $line ";" ] {
                set key [ string trim $key ]
                if { ! [ string equal "" $key ] } {
                    set key [ string range "$key" 1 end ]
                    set key [ string range "$key" 0 end-1 ]
                    set fields($key) $count
                }  
                set count [ expr $count + 1 ]
            }
        }

        set count 0
        set line ""
        while { $count >= 0 } {
            set count [gets $file line]
            if { $count < 0 } { break }

            set line [ string trim $line ]
            set row [ split $line ";" ]
            set name [ string trim [ lindex $row $fields(TEST_NAME) ] ]
            set script [ string trim [ lindex $row $fields(SCRIPT) ] ]
            set script [ file join "$subDir" "$script" ]
            set vers [ string trim [ lindex $row $fields(VERSION) ] ]
            set runFlag [ string trim [ lindex $row $fields(NO_RUN_FLAG) ] ]
            set initFlag [ string trim [ lindex $row $fields(NO_INIT_FLAG) ] ]
            if { [ string equal "" [ array names result "$name" ] ] } {
                set result($name) [list "$script" "$runFlag" "$initFlag" $vers ]
            } else {
                if { $vers >= [ lindex $result($name) 3 ] } {
                    set result($name) [list "$script" "$runFlag" "$initFlag" $vers ]
                }
            }
        }
        close $file
    }

    foreach key [ array names result ] {
        set testData(TEST_$key) $result($key)
    }
}


#______________________________________________________________________________
# A function that loads the boiler plate info

proc loadBoilerPlates { filePath platform } {
    global testData
    set pass 0
 
    while { $pass < 2 } {
        set pass [expr $pass + 1]
        if { $pass == 1 } {
            set subDir "global"
        } else {
            set subDir "$platform"
        }
        set file [open [ file join "$filePath" [ file join "$subDir" "BOILER_PLATE.csv" ] ] r]
        gets $file line
        gets $file line
        if { ! [ eof $file ] } {
            set count 0
            foreach key [ split $line ";" ] {
                set key [ string trim $key ]
                if { ! [ string equal "" $key ] } {
                    set key [ string range "$key" 1 end ]
                    set key [ string range "$key" 0 end-1 ]
                    set fields($key) $count
                }  
                set count [ expr $count + 1 ]
            }
        }

        set count 0
        set line ""
        while { ! [eof $file ] } {
            set count [gets $file line]
            if { [ eof $file ] } { continue }

            set line [ string trim $line ]
            set row [ split $line ";" ]
            set bpName [ string trim [ lindex $row $fields(BOILER_PLATE_NAME)] ]
            set result($bpName) [ file join "$subDir" [ string trim [ lindex $row $fields(SCRIPT) ] ] ]

        }
        close $file
    }
    foreach key [ array names result ] {
        set testData(BP_$key) $result($key)
    }
}


#______________________________________________________________________________
# A function that loads the environment info

proc loadEnvironments { filePath platform } {
    global testData
    set pass 0
 
    while { $pass < 2 } {
        set pass [expr $pass + 1]
        if { $pass == 1 } {
            set subDir "global"
        } else {
            set subDir "$platform"
        }
        set file [open [ file join "$filePath" [ file join "$subDir" "ENV.csv" ] ] r]
        gets $file line
        gets $file line
        if { ! [ eof $file ] } {
            set count 0
            foreach key [ split $line ";" ] {
                set key [ string trim $key ]
                if { ! [ string equal "" $key ] } {
                    set key [ string range "$key" 1 end ]
                    set key [ string range "$key" 0 end-1 ]
                    set fields($key) $count
                }  
                set count [ expr $count + 1 ]
            }
        }

        set count 0
        set line ""
        while { ! [eof $file ] } {
            set count [gets $file line]
            if { [ eof $file ] } { continue }

            set line [ string trim $line ]
            set row [ split $line ";" ]
            set envName [ string trim [ lindex $row $fields(ENV_NAME) ] ]
            set result($envName) [ file join "$subDir" [ string trim [ lindex $row $fields(PROLOG) ] ] ]

        }
        close $file
    }
    foreach key [ array names result ] {
        set testData(ENV_$key) $result($key)
    }
}


#______________________________________________________________________________
# The code to handle command substitution in the tcs.script data stream
#
proc parseEnvFile { fileName } {
    global tcsEnv
    global localEnv

    set result ""
    set file [ open $fileName r ]
    while { ! [ eof $file ] } {
        gets $file line
        if { [ eof $file ] } { continue }

        if { [ string first "::" "$line" ] != 0 } { continue }
        set line [ string range "$line" 2 end ]
        set offset [ string first " " "$line" ]
        if { $offset == -1 } {
            set srcStr "$line"
            set rplStr ""
        } else {
            set srcStr [ string range "$line" 0 [ expr $offset - 1 ]]
            set rplStr [ string range "$line" [expr $offset + 1 ] end ]
        }
        set result [ concat $result [ list [ list "$srcStr" "$rplStr" ] ] ]
        set tcsEnv($srcStr) "$rplStr"
        set localEnv($srcStr) "$rplStr"
        if { [ string first "WHERE_" ${srcStr} ] == 0 } {
            if { ! [ string equal "" ${rplStr} ] } {
                set localEnv($srcStr:) "$rplStr$localEnv(PATH_SEP)"
            }
        }
    }
    close $file
    return $result
}


#______________________________________________________________________________
# The code to handle command substitution in the tcs.script data stream
#

proc setup_tcsenv {} {
    global tcsEnv
    global localEnv
    global firebird
    global firebirdTCS
    global ISQL
    global QLI
    global GBAK
    global GDEF
    global GFIX
    global GSEC
    global GPRE
    global CC
    global CXX

    set localEnv(PATH_SEP) "/"
    set localEnv(gds_\$print_status) "gds__print_status"
    set localEnv(gds_\$status) "gds__status"
    set localEnv(GDS_\$QUAD) "GDS__QUAD"
    set localEnv(gds_\$quad) "gds__quad"
    set localEnv(GDS_\$DECODE_DATE) "GDS__DECODE_DATE"
    set localEnv(gds_\$decode_date) "gds__decode_date"
    set localEnv(GDS_\$INFO_SWEEP_INTERVAL) "GDS__INFO_SWEEP_INTERVAL"
    set localEnv(gds_\$info_sweep_interval) "gds__info_sweep_interval"
    set localEnv(GDS_\$INFO_NO_RESERVE) "GDS__INFO_NO_RESERVE"
    set localEnv(gds_\$info_no_reserve) "gds__info_no_reserve"
    set localEnv(GDS_\$EVENTS) "GDS__EVENTS"
    set localEnv(gds_\$events) "gds__events"
    set localEnv(GDS_\$INFO_END) "GDS__INFO_END"
    set localEnv(gds_\$info_end) "gds__info_end"
    set localEnv(GDS_\$INFO_READS) "GDS__INFO_READS"
    set localEnv(gds_\$info_reads) "gds__info_reads"
    set localEnv(GDS_\$INFO_WRITES) "GDS__INFO_WRITES"
    set localEnv(gds_\$info_writes) "gds__info_writes"
    set localEnv(GDS_\$INFO_FETCHES) "GDS__INFO_FETCHES"
    set localEnv(gds_\$info_fetches) "gds__info_fetches"
    set localEnv(GDS_\$INFO_MARKS) "GDS__INFO_MARKS"
    set localEnv(gds_\$info_marks) "gds__info_marks"
    set localEnv(GDS_\$INFO_PAGE_SIZE) "GDS__INFO_PAGE_SIZE"
    set localEnv(gds_\$info_page_size) "gds__info_page_size"
    set localEnv(GDS_\$INFO_NUM_BUFFERS) "GDS__INFO_NUM_BUFFERS"
    set localEnv(gds_\$info_num_buffers) "gds__info_num_buffers"
    set localEnv(GDS_\$INFO_NUM_WAL_BUFFERS) "GDS__INFO_NUM_WAL_BUFFERS"
    set localEnv(gds_\$info_num_wal_buffers) "gds__info_num_wal_buffers"
    set localEnv(GDS_\$INFO_WAL_BUFFER_SIZE) "GDS__INFO_WAL_BUFFER_SIZE"
    set localEnv(gds_\$info_wal_buffer_size) "gds__info_wal_buffer_size"
    set localEnv(GDS_\$INFO_WAL_CKPT_LENGTH) "GDS__INFO_WAL_CKPT_LENGTH"
    set localEnv(gds_\$info_wal_ckpt_length) "gds__info_wal_ckpt_length"
    set localEnv(GDS_\$INFO_WAL_CUR_CKPT_INTERVAL) "GDS__INFO_WAL_CUR_CKPT_INTERVAL"
    set localEnv(gds_\$info_wal_cur_ckpt_interval) "gds__info_wal_cur_ckpt_interval"
    set localEnv(GDS_\$INFO_WAL_GRPC_WAIT_USECS) "GDS__INFO_WAL_GRPC_WAIT_USECS"
    set localEnv(gds_\$info_wal_grpc_wait_usecs) "gds__info_wal_grpc_wait_usecs"
    set localEnv(GDS_\$INFO_WAL_NUM_IO) "GDS__INFO_WAL_NUM_IO"
    set localEnv(gds_\$info_wal_num_io) "gds__info_wal_num_io"
    set localEnv(GDS_\$INFO_WAL_AVG_IO_SIZE) "GDS__INFO_WAL_AVG_IO_SIZE"
    set localEnv(gds_\$info_wal_avg_io_size) "gds__info_wal_avg_io_size"
    set localEnv(GDS_\$INFO_WAL_NUM_COMMITS) "GDS__INFO_WAL_NUM_COMMITS"
    set localEnv(gds_\$info_wal_num_commits) "gds__info_wal_num_commits"
    set localEnv(GDS_\$INFO_WAL_AVG_GRPC_SIZE) "GDS__INFO_WAL_AVG_GRPC_SIZE"
    set localEnv(gds_\$info_wal_avg_grpc_size) "gds__info_wal_avg_grpc_size"
    set localEnv(GDS_\$INFO_CURRENT_MEMORY) "GDS__INFO_CURRENT_MEMORY"
    set localEnv(gds_\$info_current_memory) "gds__info_current_memory"
    set localEnv(GDS_\$INFO_MAX_MEMORY) "GDS__INFO_MAX_MEMORY"
    set localEnv(gds_\$info_max_memory) "gds__info_max_memory"
    set localEnv(GDS_\$INFO_ATTACHMENT_ID) "GDS__INFO_ATTACHMENT_ID"
    set localEnv(gds_\$info_attachment_id) "gds__info_attachment_id"
    set localEnv(GDS_\$INFO_ODS_VERSION) "GDS__INFO_ODS_VERSION"
    set localEnv(gds_\$info_ods_version) "gds__info_ods_version"
    set localEnv(GDS_\$INFO_ODS_MINOR_VERSION) "GDS__INFO_ODS_MINOR_VERSION"
    set localEnv(gds_\$info_ods_minor_version) "gds__info_ods_minor_version"
    set localEnv(GDS_\$INFO_ALLOCATION) "GDS__INFO_ALLOCATION"
    set localEnv(gds_\$info_allocation) "gds__info_allocation"
    set localEnv(GDS_\$INFO_READ_SEQ_COUNT) "GDS__INFO_READ_SEQ_COUNT"
    set localEnv(gds_\$info_read_seq_count) "gds__info_read_seq_count"
    set localEnv(GDS_\$INFO_READ_IDX_COUNT) "GDS__INFO_READ_IDX_COUNT"
    set localEnv(gds_\$info_read_idx_count) "gds__info_read_idx_count"
    set localEnv(GDS_\$INFO_UPDATE_COUNT) "GDS__INFO_UPDATE_COUNT"
    set localEnv(gds_\$info_update_count) "gds__info_update_count"
    set localEnv(GDS_\$INFO_INSERT_COUNT) "GDS__INFO_INSERT_COUNT"
    set localEnv(gds_\$info_insert_count) "gds__info_insert_count"
    set localEnv(GDS_\$INFO_DELETE_COUNT) "GDS__INFO_DELETE_COUNT"
    set localEnv(gds_\$info_delete_count) "gds__info_delete_count"
    set localEnv(GDS_\$INFO_BACKOUT_COUNT) "GDS__INFO_BACKOUT_COUNT"
    set localEnv(gds_\$info_backout_count) "gds__info_backout_count"
    set localEnv(GDS_\$INFO_PURGE_COUNT) "GDS__INFO_PURGE_COUNT"
    set localEnv(gds_\$info_purge_count) "gds__info_purge_count"
    set localEnv(GDS_\$INFO_EXPUNGE_COUNT) "GDS__INFO_EXPUNGE_COUNT"
    set localEnv(gds_\$info_expunge_count) "gds__info_expunge_count"
    set localEnv(GDS_\$INFO_IMPLEMENTATION) "GDS__INFO_IMPLEMENTATION"
    set localEnv(gds_\$info_implementation) "gds__info_implementation"
    set localEnv(GDS_\$INFO_BASE_LEVEL) "GDS__INFO_BASE_LEVEL"
    set localEnv(gds_\$info_base_level) "gds__info_base_level"
    set localEnv(GDS_\$INFO_VERSION) "GDS__INFO_VERSION"
    set localEnv(gds_\$info_version) "gds__info_version"
    set localEnv(GDS_\$INFO_LIMBO) "GDS__INFO_LIMBO"
    set localEnv(gds_\$info_limbo) "gds__info_limbo"
    set localEnv(GDS_\$DATABASE_INFO) "GDS__DATABASE_INFO"
    set localEnv(gds_\$database_info) "gds__database_info"
    set localEnv(GDS_\$TRANS) "GDS__TRANS"
    set localEnv(gds_\$trans) "gds__trans"
    set localEnv(GDS_\$SEGSTR_EOF) "GDS__SEGSTR_EOF"
    set localEnv(gds_\$segstr_eof) "gds__segstr_eof"
    set localEnv(GDS_\$VERSION) "GDS__VERSION"
    set localEnv(gds_\$version) "gds__version"
    set localEnv(LINE_TERM) "\n"

    set localEnv(WHERE_GDB:) ""
    set tcsEnv(WHERE_GDB) ""
    set localEnv(WHERE_GDB1:) ""
    set tcsEnv(WHERE_GDB1) ""
    set localEnv(WHERE_FILES:) "../testsuite/tcs.test/data/tests" 
    set tcsEnv(WHERE_FILES) "" 
    set localEnv(WHERE_GDB_EXTERNAL:) ""
    set tcsEnv(WHERE_GDB_EXTERNAL) ""
        
    set tcsEnv(WHERE_BIN) [ file join "$firebird" "bin" ]
    set tcsEnv(WHERE_GSEC) "$firebird"
    set tcsEnv(WHERE_HELP) [ file join "$firebird" "help" ]
    set tcsEnv(WHERE_INCLUDE3) [ file join "$firebird" "include" ]

    set tcsEnv(ADA_LINK) ""
    set tcsEnv(ADA_MKFAM) ""
    set tcsEnv(ADA_MKLIB) ""
    set tcsEnv(ADA_RMFAM) ""
    set tcsEnv(ADA_RMLIB) ""
    set tcsEnv(ADA_SEARCH) ""
    set tcsEnv(ADA_SETLIB) ""
    set tcsEnv(ADA) ""
    set tcsEnv(API) "api"
    set tcsEnv(CC) ${CC}
    set tcsEnv(CXX) ${CXX}
    set tcsEnv(COBOL) "cob"
    set tcsEnv(COB_LINK) "cob"
    set tcsEnv(COB) "cob"
    set tcsEnv(COPY) "cp "
    set tcsEnv(CREATE) "cat > "
    set tcsEnv(CRE) "cat > "
    set tcsEnv(DELETE) "rm -f "
    set tcsEnv(DEL) "rm -f "
    set tcsEnv(DIRECTORY) "ls "
    set tcsEnv(DIR) "ls "
    set tcsEnv(DROP) [ file join "$firebirdTCS" "drop_gdb" ]
    set tcsEnv(FORTRAN_LINK) "f77"
    set tcsEnv(FORTRAN) "f77"
    set tcsEnv(FOR) "f77"
    set tcsEnv(GBAK) ${GBAK}
    set tcsEnv(GCON) [ file join "$firebird" [ file join "bin" "gcon" ] ]
    set tcsEnv(GCSU) [ file join "$firebird" [ file join "bin" "gcsu" ] ]
    set tcsEnv(GDEF) ${GDEF}
    set tcsEnv(GDS_CACHE_MANAGER) [ file join "$firebird" [ file join "bin" "gds_cache_manager" ] ]
    set tcsEnv(GFIX) ${GFIX}
    set tcsEnv(GJRN) [ file join "$firebird" [ file join "bin" "gjrn" ] ]
    set tcsEnv(GLTJ) [ file join "$firebird" [ file join "bin" "gltj" ] ]
    set tcsEnv(GPRE) ${GPRE}
    set tcsEnv(GRST) [ file join "$firebird" [ file join "bin" "grst" ] ]
    set tcsEnv(GSEC) ${GSEC}
    set tcsEnv(ISQL) ${ISQL}
    set tcsEnv(JAVA) "java"
    set tcsEnv(JAVAC) "javac"
    set tcsEnv(MAKE) "make"
    set tcsEnv(PASCAL) "pas"
    set tcsEnv(PAS) "pas"
    set tcsEnv(QLI) ${QLI}
    set tcsEnv(RSH) "rsh"
    set tcsEnv(RUN) ""
    set tcsEnv(SH) "sh"
    set tcsEnv(TYPE) "cat < "
    set tcsEnv(LINK) "cc"

    set tcsEnv(HOST_CODE_EXT_C) "c"
    set tcsEnv(HOST_CODE_EXT_CXX) "cpp"
    set tcsEnv(HOST_CODE_EXT_ADA) "a"
    set tcsEnv(HOST_CODE_EXT_FTN) "ftn"
    set tcsEnv(HOST_CODE_EXT_PAS) "p"
    set tcsEnv(HOST_CODE_EXT_COB) "cbl"
}

proc platform_code_ext { fileName } {
    global tcsEnv

    set posOfDot [string last "." $fileName ]
    
    if { $posOfDot == -1 } {
        return "$tcsEnv(HOST_CODE_EXT_C)"
    }
    
    set curExt [ string range $fileName $posOfDot end ]
        
    if { ! [string compare "$curExt" ".c"] } {
        return "$tcsEnv(HOST_CODE_EXT_C)" }
    if { ! [string compare "$curExt" ".C"] } {
        return "$tcsEnv(HOST_CODE_EXT_CXX)" }
    if { ! [string compare "$curExt" ".a"] } {
        return "$tcsEnv(HOST_CODE_EXT_ADA)" }
    if { ! [string compare "$curExt" ".ftn"] } {
        return "$tcsEnv(HOST_CODE_EXT_FTN)" }
    #if { ! [string compare "$curExt" ".??"] } {
    #    return "$tcsEnv(HOST_CODE_EXT_PAS)" }
    if { ! [string compare "$curExt" ".cbl"] } {
        return "$tcsEnv(HOST_CODE_EXT_COB)" }

    # I wonder if we want to do this, or would it be better to return
    # the current extention $curExt even though we don't know it.
    #
    # JMB - or we could just fail the test.
    return ""
}

proc platform_code_root { fileName } {
    set posOfDot [string last "." $fileName ]
    
    if { $posOfDot == -1 } {
        return "$fileName"
    } else {
        return [ string range $fileName 0 [ expr $posOfDot - 1 ] ]
    }
}

proc debugPrint { line } {
#    send_user "$line\n"
}       

proc cmd_sub { line } {
    global tcsEnv

    debugPrint "initial: $line"

    set cmdList [ split "$line" { } ]
    set line ""
    while { [llength "$cmdList"] > 0 } {
        set item [ lindex "$cmdList" 0 ]
        set cmdList [ lrange "$cmdList" 1 end ]

        # handle the compile variable
        if { [ string compare "FLAG_CC" "$item" ] == 0      || \
             [ string compare "FLAG_CXX" "$item" ] == 0     || \
             [ string compare "FLAG_ADA" "$item" ] == 0     || \
             [ string compare "FLAG_FOR" "$item" ] == 0     || \
             [ string compare "FLAG_PAS" "$item" ] == 0     || \
             [ string compare "FLAG_COB" "$item" ] == 0 } {

            set fileName [ lindex "$cmdList" 0 ]
            set cmdList [ lrange "$cmdList" 1 end ]
            set prtPat "$tcsEnv($item)"
            set item [ format "$prtPat" "[platform_code_root $fileName].[platform_code_ext $fileName]" ]
            set line "$line $item"
            continue
        }

        # handle the link variable
        if { [ string compare "FLAG_LINK" "$item" ] == 0      || \
             [ string compare "FLAG_LINK_MU" "$item" ] == 0      || \
             [ string compare "FLAG_ADA_LINK" "$item" ] == 0     || \
             [ string compare "FLAG_COB_LINK" "$item" ] == 0 } {

            set fileNameList ""
            set fileNameObjs ""
            while { 0 != [ string first "LIBRARIES" [lindex "$cmdList" 0 ]] && \
                      [ llength "$cmdList" ] > 0 } {
                set fileName [ lindex "$cmdList" 0 ]
                set cmdList [ lrange "$cmdList" 1 end ]
                if { [ string equal "" "$fileNameList" ] } {
                    set fileNameList "$fileName"
                }
                set fileNameObjs "$fileNameObjs [ platform_code_root $fileName ].o"
            }
            set prtPat "$tcsEnv($item)"
            set item [ format "$prtPat" "$fileNameObjs" "$fileNameList" ]
            set line "$line $item"
            continue
        }

        if { [ string length $item ] != 0 } {
            if { [ regexp "^\[A-Za-z0-9\$\]+$" "$item" ] } {
                set findNames [ array names tcsEnv "$item" ]
                debugPrint "map: X${item}X Y${findNames}Y"

                # Check lookup to see if we have found a match (done this way so that
                # wildcards such as 'A*' still work ok.
                if { $findNames != $item  } {
                    set line "$line $item"
                } else {
                    set line "$line $tcsEnv($item)"
                }
            } else {
                set line "$line $item"
            }
        }
    }
    set line [ string range "$line" 1 end ]
    debugPrint "final: $line"

    return [ data_sub "$line" ]
}

proc data_sub { str } {
    global localEnv
    global tcsEnv

#    send_user "orig : $str\n"

    set newStr ""
    set checkStr ""

    while { [string length "$str"] > 0 } {
        if { [string is wordchar -failindex stopChar "$str"] } {
            set checkStr "$checkStr$str"
            set str ""
        } else {
            if { $stopChar == 0 } {
                # we won't let the rest of the loop complete because it might
                # call 'array names localEnv "*"', which breaks the rest of
                # the code.  Since we only pick up funny characters in this
                # if branch we just update newStr and go to the next iteration
                #
                set tmpStr [ string range "$str" 0 0 ]
                set checkStr ""
                set str [ string range "$str" 1 end ]
                set newStr "$newStr$tmpStr"
                continue

            } else {
                set tmpStr [ string range "$str" 0 [ expr $stopChar - 1 ] ]
                set checkStr "$checkStr$tmpStr"
                set str [ string range "$str" $stopChar end ]

                # check for special characters that are not in the wordchar class
                # but that should not break words.  Most notably the '$' can't
                # break words.
                if { [ string equal {$} [ string range "$str" 0 0 ] ] } {
                    set checkStr "$checkStr\$"
                    set str [ string range "$str" 1 end ]
                    continue
                }
            }
        }

        # check to see if need to do a string replacement

        set alreadyHandled 0
        if { [ string first ":" ${str} ] == 0 } {
            if {![string equal "" [ array names localEnv "$checkStr:"] ] } {
                set str [ string range "$str" 1 end ]
                set newStr "$newStr$localEnv($checkStr:)"
                set alreadyHandled 1
            }
        }

        if { ! $alreadyHandled } {
            if { [string equal "" [ array names localEnv "$checkStr" ] ] } {
                # nope
                set newStr "$newStr$checkStr"
            } else {
                set newStr "$newStr$localEnv($checkStr)"
            }
        }
        set checkStr ""
    }

    # The old, slow, cruddy substitution code
    #
    #foreach key [ array names localEnv "WHERE_*" ] {
    #    if { ! [ string compare "" "$localEnv($key)" ] } {
    #        set rplStr ""
    #    } else {
    #        set rplStr "$localEnv($key)/"
    #    }
    #
    #    regsub -all "$key:" "$str" "$rplStr" str
    #}
    #
    #foreach key [ array names localEnv ] {
    #    regsub -all "$key" "$str" "$localEnv($key)" str
    #}
    #

#    send_user "new  : $str\n"
    return "$newStr"
}

proc linesAreEquiv { source comp } {
    if { [ regexp "((SQL> )|(CON> )|(QLI> ))*Database:" ${source} matchStr ] } {
        if { [ string first "$matchStr" "$comp" ] == 0 } {
            return 1
        }
    }

    if { [ regexp "(QLI> )*\\*\\* QLI error from database " ${source} matchStr ] } {
        if { [ string first "$matchStr" "$comp" ] == 0 } {
            return 1
        }
    }

    if { [ regexp "\\(W\\) \[^\r\n\]*database " ${source} matchStr ] } {
        if { [ string first "$matchStr" "$comp" ] == 0 } {
            return 1
        }
    }

    if { [ regexp {^ *Infinity $} "$source" matchStr ] } {
        if { [ regexp {^ *Inf $} "$comp" matchStr ] } {
            return 1
        }
    }

    if { [ regexp "database \[^\r\n\]+ shutdown" ${source} ] } {
        if { [ regexp "database \[^\r\n\]+ shutdown" ${comp} ] } {
            return 1
        }
    }

    if { [ regexp "((SQL> )|(CON> )|(QLI> ))*External file: " "$source" matchStr ] } {
        if { [ string first "$matchStr" "$comp" ] == 0 } {
            return 1
        }
    }

    set matchPos [ string last "CREATE DATABASE" [ string toupper "$source"] ]
    if { $matchPos != -1 && $matchPos <= 14 } {
        if { [ string length "$comp" ] > 14 } {
            if { [ string compare "CREATE DATABASE" [ string range [ string toupper "$comp" ] 0 14 ] ] == 0 } {
                return 1
            }
        }
    }

    # the default action
    return [ expr [ string compare "$source" "$comp" ] == 0 ]
}

proc start_shell {} {
    global spawn_id
    global shellPrompt
    global localEnv

    spawn "/bin/sh"
    set shellPrompt "shell> "
    send "PS1='$shellPrompt'$localEnv(LINE_TERM)"
    set timeout 10
    expect {
        -re "\[^\]*\[^\'\]$shellPrompt" { }
        timeout { send_user "TIMEOUT\n"; send "exit$localEnv(LINE_TERM)"; return 0 }
        eof { send_user "Premature EOF!!\n"; send "exit$localEnv(LINE_TERM)"; return 0 }
    }
    send "cd work$localEnv(LINE_TERM)"
    expect {
        -re "\[^\]*\[^\'\]$shellPrompt" { return 1 }
        timeout { send_user "TIMEOUT\n" }
        eof { send_user "Premature EOF!!\n" }
    }
    send "exit$localEnv(LINE_TERM)"
    return 0
}

proc stop_shell {} {
    global spawn_id
    global shellPrompt
    global localEnv

    send "exit$localEnv(LINE_TERM)"
    set timeout 10
    expect {
        eof { wait; return 1 }
        timeout { }
    }
    close
    #exec kill $pid
    wait
    return 1
}



# This is the fun little procedure that correctly handles the stdout/stderr
# streams.

proc doTcsDiff { srcScript outputFile configFile } {
    global testTimeout
    global localEnv
    global spawn_id
    global shellPrompt

    set errLine ""
    set splitFile 0
    set errBuff ""
    set fileOpen 1
    set failMsg ""
    set blankCount 0
    set lastMatch 1

    set stdoutMatch 1
    set stderrMatch 0
    set timeout 5

    match_max -d
    set thisTestTimeout $testTimeout

    if { [ file exists "$configFile" ] } {
        set file [ open "$configFile" r ]
        while { ! [ eof $file ] } {
            gets $file line
            if { [eof $file] } { break }

            set line [ string trim "$line" ]
            if { [ string equal "" "$line" ] } { continue }
            set line [ split "$line" "=" ]
            set key [ string toupper [ string trim [ lindex "$line" 0 ] ] ]
            set value [ string trim [ lindex "$line" 1 ] ]
            switch "$key" {
                "TIMEOUT" { set thisTestTimeout $value }
                "BUFFER" { match_max $value }
            }
        }
        close $file
    }

    set timeout 5
    send "$localEnv(LINE_TERM)"
    expect {
        -re "$shellPrompt" { }
        timeout {
            stop_shell
            if { ! [ start_shell ] } {
                send_user "Unrecoverable error!\n"
            }
            return "TIMEOUT waiting for starting shell prompt"
        }
        eof { set fileOpen 0; fail "Premature EOF!!"; start_shell; return }
    }

    send "source $srcScript$localEnv(LINE_TERM)"

#        -re {^[^\r\n]*$srcScript\r\n} { }
    expect {
        -re "source $srcScript\[\r\n\]+" { }
        timeout {
            stop_shell
            if { ! [ start_shell ] } {
                send_user "Unrecoverable error!\n"
            }
            return "TIMEOUT waiting for script command echo"
        }
        "$shellPrompt" { set failMsg "Premature end of output" }
        eof { set fileOpen 0; set failMsg "Premature EOF!!" }
    }

    set file [ open "$outputFile" r ]

    while { ! [ eof $file ] } {
        if { $stdoutMatch == 1 } {
            gets $file line
            if { [eof $file] } { continue }
        }
        if { $stderrMatch == 1 } {
            if { [ llength $errBuff ] == 0 } {
                set errLine ""
                set splitFile 2
            } else {
                set errLine [ lindex $errBuff 0 ]
                set errBuff [ lrange $errBuff 1 end ]
                #send_user "errline: $errLineX\n"
                #send_user $errBuff
                #send_user "\n"
            }
        }

        set stdoutMatch 0
        set stderrMatch 0
        set wildcardMatch 0
        set timeout $thisTestTimeout

# On win32 some of the returned lines have \r\r\n as the delimiter
# the [ have to be escaped, and # comments cannot appear in the
# expect statement.
        expect {
            -re "^\[^\r\n\]*\r\r\n" {
                set output [ string range "$expect_out(buffer)" 0 end-3 ] }
            -re "^\[^\r\n\]*\r\n" {
                set output [ string range "$expect_out(buffer)" 0 end-2 ] }
            -re "^\[^\r\n\]*\r" {
                set output [ string range "$expect_out(buffer)" 0 end-1 ] }

            timeout {
                stop_shell
                if { ! [ start_shell ] } {
                    send_user "Unrecoverable error!\n"
                }
                set fileOpen 0
                set failMsg "TIMEOUT waiting for: $output"
                break
            }
            "$shellPrompt" { set failMsg "Premature end of output"; break }
            eof { set fileOpen 0; set failMsg "Premature EOF!!"; break }
        }

#        set output [ string trim "$expect_out(buffer)" ]
#        set line   [ string trim $line ]
#        send_user "$output\n"

        # There are some lines that just need to be skipped in the output.
        # For example some shells report the process number when a background
        # process is created.  This code handles those special lines of output.
        if { [ regexp {^\[[0-9]+\] [0-9]+$} ${output} ] } {
            continue
        }

        if { [ linesAreEquiv "$line" "$output" ] } {
            # This is a funny case.  It basically says if the last matched line
            # came from stderr, the current line is blank (""), and both
            # of the next expected lines for stdout and stderr are blank, give
            # the blank space to stderr.
            if { [ string compare "" "$line" ] == 0  && \
                 $lastMatch == 2 && $splitFile == 1 && \
                 [ string compare "" "$errLine" ] == 0 } {
                set stderrMatch 1
            } else {
                set stdoutMatch 1
            }
        } else {
            if {$splitFile == 1 && [ linesAreEquiv "$errLine" "$output"] } {
                set stderrMatch 1
            } else {
                set wildcardMatch 1
            }
        }

        # Check to see if the wildcard failed because of a 'special' line
        # if not then we have a test error
        if { $wildcardMatch == 1 } {
            # test error case
            if { $splitFile != 0 } {
                stop_shell
                if { ! [ start_shell ] } {
                    send_user "Unrecoverable error!\n"
                }
                set failMsg "Unexpected output: $output"
                break
            }

            if { $splitFile == 0 } {
                # There is funny problem with the "" string when searching for
                # the start of the stdout stream.  Basically, you match a blank
                # in the stderr stream instead of the stdout stream.  We just
                # ignore blanks for now.  That is safe because the must have
                # come from stdout, or else stderr *would* have matched and we
                # wouldn't be here.  Instead we just count the number of blanks
                # we ignore and insure they are at the beginning of the stdout
                # stream once we find it.
                if { [string compare "" "$output"] == 0 } {
                    set blankCount [ expr $blankCount + 1 ]
                } else {
                    # At this point we assume the output file is split, and
                    # search for the line that matches the current ouput line.
                    # We just assume
                    # that this line is the start of the stdout stream.
                    set splitFile 1
                    set foundMatch 0
                    while { ! [ eof $file ] } {
                        gets $file checkLine
                        if { [eof $file] } { continue }
                        if { [ linesAreEquiv "$checkLine" "$output" ] } {
                            set foundMatch 1
                            break
                        }
                        set errBuff [ concat $errBuff [ list "$checkLine" ] ]
                    }
                    if { $foundMatch == 0 } {
                        stop_shell
                        if { ! [ start_shell ] } {
                            send_user "Unrecoverable error!\n"
                        }
                        set failMsg "Unexpected output: $output"
                        break
                    }
                    set errLine "$line"
                    set stdoutMatch 1
                    set stderrMatch 0
                    while { $blankCount > 0 } {
                        set blankCount [ expr $blankCount - 1 ]
                        set checkItem [ lindex $errBuff end ]
                        set errBuff [ lrange $errBuff 0 end-1 ]
                        if { [ string compare "$checkItem" "" ] != 0 } {
                            set failMsg "Unexpected blank in stream"
                            break
                        }
                    }
                    #send_user $errBuff
                    #send_user "\n"
                }
            }
        }

        if { $stdoutMatch == 1 } {
            #send_user "stdout: $output\n"
            set lastMatch 1
        }
        if { $stderrMatch == 1 } {
            #send_user "stderr: $output\n"
            set lastMatch 2
        }
    }
    if { $fileOpen == 0 } { return $failMsg }
    close $file
    if { ! [ string equal "" "$failMsg" ] } { return $failMsg }

    set timeout $thisTestTimeout
    expect {
        -re "$shellPrompt" { }
        timeout { set failMsg "TIMEOUT waiting for last shell prompt" }
        timeout {
            stop_shell
            if { ! [ start_shell ] } {
                send_user "Unrecoverable error!\n"
            }
            set failMsg "TIMEOUT waiting for last shell prompt"
        }
        eof { set fileOpen 0; set failMsg "Premature EOF!!"; break }
    }

    return $failMsg
}

#______________________________________________________________________________
# The code to run a single test
#
# My reading of the input file format is everything before the first $ command
#  is a comment.  All lines of code between two $'s constitute a data file
#   (a tcs.dataX file).

proc runKnownTest { scriptFile dataFiles outputFile bpFile envFile keep_files } {
    global saveSeriesDataRoot
    global saveSeriesResultsRoot
    global testData
    global spawn_id

    set lastCmd ""

    set dataCnt -1
    set lastWasCmd 0
    set dataFileOpen 0
    set testFiles "work/tcs.script"

    if { ! [ file exists "$scriptFile" ] } {
        return "XFAIL no test script"
    }

    if { ! [ file exists "$outputFile" ] } {
        return "XFAIL no expected output file"
    }

    set fileRoot [ file rootname "$scriptFile" ]
    set configFile "$fileRoot.config"
    set script [open "work/tcs.script" w]
    set env [ parseEnvFile "$envFile" ]
    set expectPass 1

    if { [ file exists "$configFile" ] } {
        set file [ open "$configFile" r ]
        while { ! [ eof $file ] } {
            gets $file line
            if { [eof $file] } { break }

            set line [ string trim "$line" ]
            if { [ string equal "" "$line" ] } { continue }
            set line [ split "$line" "=" ]
            set key [ string toupper [ string trim [ lindex "$line" 0 ] ] ]
            set value [ string trim [ lindex "$line" 1 ] ]
            switch "$key" {
                "RESULT" { if { [ string equal "FAIL" [ string toupper ${value} ] ] } { set expectPass 0 } }
            }
        }
        close $file
    }


    # Copy over the boiler plate
    set file [open "$scriptFile" r]
    set bp [ open "$bpFile" r ]
    while { ! [ eof $bp ] } {
        set count [ gets $bp line ]
        if { $count < 0 } { continue }
        puts $script "$line"
    }
    close $bp

    # Break the source script into tcs.script and tcs.dataX
    while { ! [ eof $file ] } {
        set count [gets $file line]
        if { $count < 0 } { continue }

        set matchPos [string first {$} ${line} ]
        if { $matchPos != 0 } {
            if { $lastWasCmd == 1 } {
                set lastWasCmd 0
                set lastCmdLine ""
                set dataCnt [ expr $dataCnt + 1 ]
                set dataFile [open "work/tcs.data$dataCnt" w]
                set dataFileOpen 1
                set testFiles [ concat $testFiles "work/tcs.data$dataCnt" ]
                puts $script "$lastCmd < tcs.data$dataCnt"
            }
            if { $dataFileOpen == 1 } {
                puts $dataFile [ data_sub ${line} ]
            }
        } else {
            if { $dataFileOpen == 1 } {
                close $dataFile
                set dataFileOpen 0
            }
            if { $lastWasCmd == 1 } { puts $script "$lastCmd" }
            set lastWasCmd 1
            set line [ string trim [ string range "$line" 1 end ] ]
            set lastCmd [ cmd_sub ${line} ]
        }
    }
    if { $lastWasCmd == 1 } { puts $script "$lastCmd" }

    if { $dataFileOpen == 1 } {
        close $dataFile
        set dataFileOpen 0
    }

    close $script
    close $file

    foreach dataFile "$dataFiles" {
        set in [ open "$dataFile" r ]
        set out [ open [ file tail "work/$dataFile" ] w ]
        while { ! [ eof $in ] } {
            gets $in line
            if { [ eof $in ] } { break }
            puts $out [ data_sub "$line" ]
        }
        close $in
        close $out
    }

    # Now that all the files have been extracted, lets run the test!!
    set testResult [ doTcsDiff "tcs.script" "$outputFile" "$configFile" ]

    # delete the files we created
    if { ! $keep_files } {
        foreach filename $testFiles { file delete -force $filename }
        foreach filename $dataFiles \
            { file delete -force [ file tail "$filename" ] }
    }
    file delete -force "tcs.log"

    if { $expectPass != 0 } {
        if { ![ string equal "" ${testResult} ] } {
            return "FAIL $testResult"
        }
    } else {
        if { [ string equal "" ${testResult} ] } {
            return "XPASS"
        } else {
            return "XFAIL $testResult"
        }
    }

    return $testResult
}


#______________________________________________________________________________
# The code to run a series

proc runKnownSeries { seriesName subSeries platform } {
    global testData
    set seriesName [ string toupper "$seriesName" ]
    set subSeries [ string toupper "$subSeries" ]
    set prefix "testsuite/tcs.test/data/global/$seriesName"
    set oprefix "testsuite/tcs.test/data/output/$seriesName"
    set envprefix "testsuite/tcs.test/data/global/tcs_setup"
    set errMsg ""

    if { [ catch {open [ file join "$prefix" "$subSeries.series" ] r} fid] } {
        fail "Failed to open series TOC for $seriesName: $fid"
        return
    }

    while { ! [eof $fid ] } {
        gets $fid line
        if { [ eof $fid ] } { continue }

	send_user "\t$line..."
        set line [ string trim $line ]
        if { [ catch {runKnownTest [ file join "$prefix" "$line.script" ] "" \
                              [ file join "$oprefix" "$line.output" ] \
                              [ file join "$envprefix" "BP.$platform" ] \
                              [ file join "$envprefix" "ENV.$platform" ] \
          0} errMsg ] } {
            fail "Exception caught: $errMsg"
        } else {
            if { [ string equal "" "$errMsg" ] } {
                send_user "PASS\n"
                pass "$line"
            } else {
                switch [ lindex ${errMsg} 0 ] {
                    "PASS" { send_user "PASS\n"; pass "$line" }
                    "XPASS" { xpass "$line" }
                    "FAIL" { fail "$line [ string range ${errMsg} 5 end ]" }
                    "XFAIL" { send_user "EXPECTED FAILUE: [ string range ${errMsg} 6 end ]\n"; xfail "$line [ string range ${errMsg} 6 end ]" }
                }
            }
        }
    }
    close $fid
}

#______________________________________________________________________________
# The code to run a meta-series

proc runMetaSeries { metaSeries platform } {
    global testData
    set metaSeries [ string toupper "$metaSeries" ]

    if { [ catch {open "testsuite/tcs.test/data/global/$metaSeries.meta" r} fid] } {
        return 0
    }
    while { ! [eof $fid ] } {
        gets $fid line
        if { [ eof $fid ] } { continue }

        set line [ string trim $line ]
	send_user "$line...\n"
        runKnownSeries "$line" "$line" "$platform"
    }
    close $fid
    return 1
}



#______________________________________________________________________________
# The code to locate the series a test resides in given the test name

proc runTest { testName platform saveFiles } {
    set testName [ string toupper "$testName" ]

    send_user "$testName..."
    if { [ catch { glob "testsuite/tcs.test/data/global/*/$testName.script" } test_list ] } {
        fail "$testName $test_list"
        return;
    }
    if { [ llength "$test_list" ] != 1 } {
        fail "$testName Ambigous test name"
        return
    }
    set testScript [ lindex "$test_list" 0 ]
    set seriesName [ lindex [ file split "$testScript" ] end-1 ]

    set prefix "testsuite/tcs.test/data/global/$seriesName"
    set oprefix "testsuite/tcs.test/data/output/$seriesName"
    set envprefix "testsuite/tcs.test/data/global/tcs_setup"
    set errMsg ""

    if { [ catch {runKnownTest "$testScript" "" \
                              [ file join "$oprefix" "$testName.output" ] \
                              [ file join "$envprefix" "BP.$platform" ] \
                              [ file join "$envprefix" "ENV.$platform" ] \
      $saveFiles } errMsg ] } {
        fail "Exception caught: $errMsg"
    } else {
        if { [ string equal "" "$errMsg" ] } {
            send_user "PASS\n"
            pass "$testName"
        } else {
            switch [ lindex ${errMsg} 0 ] {
                "PASS" { send_user "PASS\n"; pass "$testName" }
                "XPASS" { xpass "$testName" }
                "FAIL" { fail "$testName [ string range ${errMsg} 5 end ]" }
                "XFAIL" { send_user "EXPECTED FAILUE: [ string range ${errMsg} 6 end ]\n"; xfail "$testName [ string range ${errMsg} 6 end ]" }
            }
        }
    }
}



#______________________________________________________________________________
# The code to locate a sub-series and run it, given a name

proc runSeries { seriesName platform } {
    set seriesName [ string toupper "$seriesName" ]

    if { [ catch { glob "testsuite/tcs.test/data/global/*/$seriesName.series" } test_list ] } {
        return 0;
    }
    send_user "$seriesName...\n"
    if { [ llength "$test_list" ] != 1 } {
        fail "$seriesName Ambigous series name"
        return
    }

    set masterSeriesName [ lindex [ file split "$test_list" ] end-1 ]
    runKnownSeries "$masterSeriesName" "$seriesName" "$platform"
    return 1
}


#______________________________________________________________________________
# The code that does the testing

set moduleName TCS
set databaseName "work/limits.gdb"
setup_tcsenv
#load_test_data "testsuite/tcs.test/data" ${platform}

set saveSeriesDataRoot testsuite/tcs.test/data
set saveSeriesResultsRoot testsuite/tcs.test/results

set exportedData ../test-files/export

send_user "Testing platform: $platform\n"

set testTimeout 180

if { ! [start_shell] } {
    send_user "Failed to start shell!!\n"
}


if { [ info exists TCS_TEST ] && ! [ string equal "" "$TCS_TEST" ] } {
    foreach test "$TCS_TEST" {
        if { ! [ runMetaSeries "$test" "$platform" ] } {
            if { ! [ runSeries "$test" $platform ] } {
                runTest "$test" "$platform" 1
            }
        }
    }
} else {
    runMetaSeries VECTOR_12HOUR    $platform

    #runSeries CF_ISQL             $platform

    #runSeries C_SQL_PRED          $platform
    #runSeries ISC_ARRBLOB_CK      $platform

    #runSeries DSQL_DOMAINS        $platform
    #runSeries DSQL_EXCEPTIONS     $platform
    #runSeries SQL_EVENTS          $platform
    #runSeries C_SQL_BLOB          $platform
    #runSeries C_SQL_JOIN          $platform
    #runSeries V4_AUTO_COMMIT      $platform
    #runSeries V4_EXCLUSIVE        $platform
    #runSeries IDML_C_CHARSET      $platform
    #runSeries IDML_C_SUBQUERYS    $platform

    #set testTimeout 60000
    #runSeries EVENT_MISC          $platform
    
    #set testTimeout 60
    
    #runSeries EXT_LEV_0           $platform
    #runSeries GF_SHUTDOWN         $platform
    #runSeries QA_PROC_IES_ERR     $platform
    #runSeries REF_INT_INDX        $platform
    #runSeries RICH_FLD_GEN_V40    $platform
    #runSeries RI_TESTS            $platform
    #runSeries V4_AUTO_DDL_DSQL    $platform
    #runSeries V4_TRANS_BLOB       $platform
    #runSeries QA_PROCS_ISQL       $platform
    #runSeries FB_SQL              $platform


    #runTest ISC_ER36 $platform 1
    #runTest C_DSQL_RI_INIT  $platform 1
    #runTest C_DSQL_RI_ALT_ADD  $platform 1
    #runTest C_DSQL_RI_CLEAN_UP  $platform 1

    #runTest C_SQL_JOIN_0  $platform 1
    #runTest CF_ISQL_01  $platform 1
    #runTest CF_ISQL_11  $platform 1
    #runTest CF_ISQL_16  $platform 1

    #runTest DSQL_DOMAIN_08  $platform 1
    #runTest DSQL_EXCEPT_01  $platform 1

    #set timeout 20000
    #runTest SQL_EVENT_12  $platform 1
    #runTest GF_SHUT_2  $platform 1


    # The following has a problem with LD -> ld in the input file.
    #runTest CF_ISQL_17  $platform 1


    # just testing
    #runTest C_SQL_PRED_0  $platform 1
    #runTest AUTO_COMMIT.1.ESQL $platform 1
    #runTest IDML_C_SUBQ_10 $platform 1
}

stop_shell
